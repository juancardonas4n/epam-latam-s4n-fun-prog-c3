# Un patrón recorre las listas



* Uhm, esto ya lo había visto
* Cierto, cierto, he visto un "lindo gatito"
* Función `reducir`
* Entendiendo el funcionamiento de `reducir`



---



## Uhm, esto ya lo había visto

* Observemos un momento las siguientes implementaciones de las funciones `suma` y `mult`:
```.scala
object Lista {
  ...
  def suma(lista:Lista[Int]):Int = {
    case Vacia         => 0
    case Constr(e,lst) => e + suma(lst) 
  }
  ...
  def mult(lista:Lista[Double]):Double = {
    case Vacia         => 1.0
    case Constr(e,lst) => e * mult(lst)
  }
  ...
}
```


---



## Cierto, cierto, he visto un "lindo gatito"

* La coincidencia de patrones (*pattern matching*) es la misma.
* Hay dos diferencias:
  * El valor que retorna `Vacia`
  * La función que se aplica con `Constr`.
* Pero los tipos son diferentes (Generalización)
* Crear una función parametrizada:
```.scala
def sumaomult ...
```



---



## Función `reducir`

* Algunos autores llaman la anterior función `reducir`
* Otros nombres: `doblar`, `plegar`, etc. 
```.scala
   def reducir[A,B](lista:Lista[A])(c:B)(op:(A,B) => B):B = lista match {
     case Vacia         => c
     case Constr(e,lst) => op(e,reducir(lst)(c)(op))
   }
   
   def suma(lista:Lista[Int])    = reducir(lista)(0)(_+_)
   def mult(lista:Lista[Double]) = reducir(lista)(1.0)(_*_)
```



---



## Entendiendo el funcionamiento de `reducir`

* En la siguiente figura, se observa el comportamiento de `reducir`

![Imagen no completada](imagen/reducir.png)

---



## Funciones de plegado

* La función de `reducir` vista es una de las dos funciones de plegado.
* `reducir` se conoce también como `reducirDerecha`
* Existe otra función de reducción `reducirIzquierda`
* Su funcionamiento se observa en la siguiente figura

![Imagen no completada](imagen/reducirIzquierda.png)



---



## Resumiendo las funciones de plegado

* Son dos tipos:

```.scala
def reducirDerecha[A,B](lista:Lista[A])(c:B)(op:(A,B) => B):B = lista match {
  case Vacia         => c
  case Constr(e,lst) => op(e,reducir(lst)(c)(op))
}

def reducirIzquierda[A,B](lista:Lista[A])(c:B)(op:(B,A) => B):B = lista match {
   case Vacia         => c
   case Constr(e,lst) => reducirIzquierda(lst)(op(c,e))(op)
}
```

* Asociatividad de `op`
* [Me falta definir cosas en esta parte]



---



## Función de mapeo



* Es una versión especial de las funciones de plegado. 
* La observamos en estas funciones:

```.scala

```



---



## Cierre



* Paso de parámetros permite pasar funciones.
* Patrones de código se pueden parámetrizar.
* 